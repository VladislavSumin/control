package ru.vs.control.server.feature.dns_sync.domain

import co.touchlab.kermit.Logger
import kotlinx.coroutines.CoroutineName
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import ru.vs.control.server.feature.dns_sync.repository.DnsRecord
import ru.vs.control.server.feature.dns_sync.repository.DnsRecordsRepository
import ru.vs.control.server.feature.dns_sync.repository.DnsServer
import ru.vs.control.server.feature.dns_sync.repository.DnsServersRepository
import ru.vs.core.mikrotik.MikrotikClient
import ru.vs.core.mikrotik.connection.MikrotikConnection
import ru.vs.core.mikrotik.dsl.MikrotikId
import ru.vs.core.mikrotik.dsl.ip.dns.MikrotikDnsRecord

interface DnsSyncInteractor {
    suspend fun init()
}

internal class DnsSyncInteractorImpl(
    private val serversRepository: DnsServersRepository,
    private val dnsRecordsRepository: DnsRecordsRepository,
    private val mikrotikClient: MikrotikClient,
//    private val scope: CoroutineScope
) : DnsSyncInteractor {
    override suspend fun init() = withContext(CoroutineName("DnsSyncInteractor#init")) {
        logger.i("Init DnsSync feature")

        val servers = serversRepository.observeDnsServers().first()
        val dnsRecords = dnsRecordsRepository.observeDnsRecords().first()
        servers.forEach { synchronizeDnsRecords(it, dnsRecords) }
    }

    private suspend fun synchronizeDnsRecords(server: DnsServer, dnsRecords: List<DnsRecord>) {
        // Большое количество записей тут не придвидится, поэтому можно не париться с оптимизацией кода
        val dnsRecordNames = dnsRecords.map { it.host }
        mikrotikClient.connect(server) {
            val remoteRecords = dsl.ip.dns.static.print()
                .filter { it.comment == COMMENT }
            val remoteRecordsNames = remoteRecords.map { it.name }

            // Step 1: Remove old records
            val toRemove = remoteRecords.filter { it.name !in dnsRecordNames }
            logger.d { "Found ${toRemove.size} records to remove: ${toRemove.map { "${it.id} ${it.name}" }}" }
            toRemove.forEach { dsl.ip.dns.static.remove(it) }

            // Step 2: Add new records
            val toAdd = dnsRecords
                .filter { it.host !in remoteRecordsNames }
                .map {
                    MikrotikDnsRecord(
                        name = it.host,
                        address = it.ip,
                        ttl = "1d",
                        comment = COMMENT
                    )
                }
            logger.d { "Found ${toAdd.size} records to add: ${toAdd.map { "${it.id} ${it.name}" }}" }
            toAdd.forEach { dsl.ip.dns.static.add(it) }

            // Step 3: Modify changed records
            val toModify = remoteRecords
                .mapNotNull { remoteRecord ->
                    val localRecord = dnsRecords.find { it.host == remoteRecord.name } ?: return@mapNotNull null
                    if (remoteRecord.name == localRecord.host && remoteRecord.address == localRecord.ip) return@mapNotNull null
                    remoteRecord.id to localRecord
                }
                .map { (id, record) ->
                    MikrotikDnsRecord(
                        id = id,
                        name = record.host,
                        address = record.ip,
                        ttl = "1d",
                        comment = COMMENT
                    )
                }
            logger.d { "Found ${toAdd.size} records to modify: ${toModify.map { "${it.id} ${it.name}" }}" }
            toModify.forEach { dsl.ip.dns.static.set(it) }
        }
    }

    companion object {
        private val logger = Logger.withTag("DnsSync")
        private const val COMMENT = "This record generated by Control. Don`t change it manually"
    }
}

private suspend fun MikrotikClient.connect(server: DnsServer, action: suspend MikrotikConnection.() -> Unit) =
    connect(server.host, server.port, server.login, server.password(), action)